#include <iostream>
#include <string>
#include <list>

using namespace std;

// User class representing a user's details
class User {
public:
    string firstName;
    string lastName;
    string birthdate;

    User(const string& first, const string& last, const string& date)
        : firstName(first), lastName(last), birthdate(date) {}

    // Hash function for generating a unique identifier based on user details
    int generateHash() const {
        // A simple hash function for demonstration purposes
        // You may want to use a more robust hash function in a real-world scenario
        return hash<string>{}(firstName + lastName + birthdate);
    }
};

// HashNode class representing a node in the hash table
class HashNode {
public:
    int key;  // Unique identifier generated by the hash function
    User user; // User details
};

// HashTable class with chaining to handle collisions
class HashTable {
private:
    static const int TABLE_SIZE = 10;
    list<HashNode>* table;

public:
    HashTable() {
        table = new list<HashNode>[TABLE_SIZE];
    }

    ~HashTable() {
        delete[] table;
    }

    // Function to add a new user to the hash table
    void addUser(const User& user) {
        int key = user.generateHash() % TABLE_SIZE;
        HashNode newNode;
        newNode.key = key;
        newNode.user = user;

        table[key].push_back(newNode);
    }

    // Function to search for a user in the hash table
    void searchUser(const User& user) {
        int key = user.generateHash() % TABLE_SIZE;

        for (const auto& node : table[key]) {
            if (node.user.firstName == user.firstName &&
                node.user.lastName == user.lastName &&
                node.user.birthdate == user.birthdate) {
                cout << "User found with key " << key << "\n";
                return;
            }
        }

        cout << "User not found\n";
    }

    // Function to delete a user from the hash table
    void deleteUser(const User& user) {
        int key = user.generateHash() % TABLE_SIZE;

        auto& userList = table[key];
        auto it = find_if(userList.begin(), userList.end(), [&user](const HashNode& node) {
            return node.user.firstName == user.firstName &&
                   node.user.lastName == user.lastName &&
                   node.user.birthdate == user.birthdate;
        });

        if (it != userList.end()) {
            userList.erase(it);
            cout << "User deleted from key " << key << "\n";
        } else {
            cout << "User not found for deletion\n";
        }
    }
};

int main() {
    HashTable userTable;

    // Adding users to the hash table
    User user1("John", "Doe", "1990-01-15");
    User user2("Jane", "Smith", "1985-05-22");
    User user3("Alice", "Johnson", "1992-11-30");

    userTable.addUser(user1);
    userTable.addUser(user2);
    userTable.addUser(user3);

    // Searching for users
    User searchUser("Jane", "Smith", "1985-05-22");
    userTable.searchUser(searchUser);

    // Deleting a user
    User deleteUser("John", "Doe", "1990-01-15");
    userTable.deleteUser(deleteUser);

    return 0;
}

//end of hashing








//merge sort
#include <iostream>
using namespace std;
void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    // Create temporary arrays
    int leftArr[n1];
    int rightArr[n2];

    // Copy data to temporary arrays leftArr[] and rightArr[]
    for (int i = 0; i < n1; i++)
        leftArr[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        rightArr[j] = arr[mid + 1 + j];

    // Merge the temporary arrays back into arr[left..right]
    int i = 0; // Initial index of first subarray
    int j = 0; // Initial index of second subarray
    int k = left; // Initial index of merged subarray

    while (i < n1 && j < n2) {
        if (leftArr[i] <= rightArr[j]) {
            arr[k] = leftArr[i];
            i++;
        } else {
            arr[k] = rightArr[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements of leftArr[], if there are any
    while (i < n1) {
        arr[k] = leftArr[i];
        i++;
        k++;
    }

    // Copy the remaining elements of rightArr[], if there are any
    while (j < n2) {
        arr[k] = rightArr[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        // Same as (left + right) / 2, but avoids overflow for large left and right
        int mid = left + (right - left) / 2;

        // Sort first and second halves
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);

        // Merge the sorted halves
        merge(arr, left, mid, right);
    }
}

int main() {
    const int arrSize = 6;
    int arr[arrSize] = {12, 11, 13, 5, 6, 7};

    cout << "Original array: ";
    for (int i = 0; i < arrSize; i++) {
        cout << arr[i] << " ";
    }
    cout << "\n";

    // Perform Merge Sort
    mergeSort(arr, 0, arrSize - 1);

    cout << "

















//quick sort

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
using namespace std;

class StudentRecord {
public:
    int id;
    string name;
    double gpa;
    string department;

    StudentRecord(int _id, const string& _name, double _gpa, const string& _department)
        : id(_id), name(_name), gpa(_gpa), department(_department) {}
};

class StudentRecordOrganizer {
private:
    vector<StudentRecord> records;

    void quickSort(int low, int high) {
        if (low < high) {
            int pivotIndex = partition(low, high);
            quickSort(low, pivotIndex - 1);
            quickSort(pivotIndex + 1, high);
        }
    }

    int partition(int low, int high) {
        int pivot = records[high].id;
        int i = low - 1;

        for (int j = low; j <= high - 1; j++) {
            if (records[j].id < pivot) {
                i++;
                swap(records[i], records[j]);
            }
        }

        swap(records[i + 1], records[high]);
        return i + 1;
    }

public:
    void addRecord(const StudentRecord& record) {
        records.push_back(record);
    }

    void modifyRecord(int id, const string& newName, double newGPA, const string& newDepartment) {
        auto it = find_if(records.begin(), records.end(), [id](const StudentRecord& record) {
            return record.id == id;
        });

        if (it != records.end()) {
            it->name = newName;
            it->gpa = newGPA;
            it->department = newDepartment;
        } else {
            cout << "Record not found.\n";
        }
    }

    void removeRecord(int id) {
        auto it = remove_if(records.begin(), records.end(), [id](const StudentRecord& record) {
            return record.id == id;
        });

        if (it != records.end()) {
            records.erase(it, records.end());
        } else {
            cout << "Record not found.\n";
        }
    }

    void displaySortedRecords() {
        quickSort(0, records.size() - 1);

        cout << "Sorted Student Records:\n";
        for (const auto& record : records) {
            cout << "ID: " << record.id << ", Name: " << record.name
                 << ", GPA: " << record.gpa << ", Department: " << record.department << endl;
        }
    }
};

int main() {
    StudentRecordOrganizer organizer;

    // Adding sample records
    organizer.addRecord(StudentRecord(101, "John Doe", 3.8, "Computer Science"));
    organizer.addRecord(StudentRecord(102, "Jane Smith", 3.5, "Physics"));
    organizer.addRecord(StudentRecord(103, "Bob Johnson", 3.2, "Mathematics"));
    organizer.addRecord(StudentRecord(104, "Alice Brown", 3.9, "Chemistry"));

    // Displaying initial records
    cout << "Initial Student Records:\n";
    organizer.displaySortedRecords();

    // Modifying a record
    organizer.modifyRecord(102, "Jane Johnson", 3.7, "Biology");

    // Displaying records after modification
    cout << "\nStudent Records after Modification:\n";
    organizer.displaySortedRecords();

    // Removing a record
    organizer.removeRecord(103);

    // Displaying records after removal
    cout << "\nStudent Records after Removal:\n";
    organizer.displaySortedRecords();

    return 0;
}

//end of quick sort






















//avl
#include <iostream>
#include <string>
using namespace std;

class PlayerRecord {
public:
    string username;
    int score;
    int rank;

    PlayerRecord(const string& name, int s) : username(name), score(s), rank(0) {}
};

class AVLNode {
public:
    PlayerRecord player;
    int height;
    AVLNode* left;
    AVLNode* right;

    AVLNode(PlayerRecord p) : player(p), height(1), left(nullptr), right(nullptr) {}
};

class AVLTree {
private:
    AVLNode* root;

    int height(AVLNode* node) {
        return (node == nullptr) ? 0 : node->height;
    }

    int balanceFactor(AVLNode* node) {
        return (node == nullptr) ? 0 : height(node->left) - height(node->right);
    }

    AVLNode* rightRotate(AVLNode* y) {
        AVLNode* x = y->left;
        AVLNode* T2 = x->right;

        // Perform rotation
        x->right = y;
        y->left = T2;

        // Update heights
        y->height = 1 + max(height(y->left), height(y->right));
        x->height = 1 + max(height(x->left), height(x->right));

        return x;
    }

    AVLNode* leftRotate(AVLNode* x) {
        AVLNode* y = x->right;
        AVLNode* T2 = y->left;

        // Perform rotation
        y->left = x;
        x->right = T2;

        // Update heights
        x->height = 1 + max(height(x->left), height(x->right));
        y->height = 1 + max(height(y->left), height(y->right));

        return y;
    }

    AVLNode* insertNode(AVLNode* node, PlayerRecord player) {
        // Perform standard BST insertion
        if (node == nullptr)
            return new AVLNode(player);

        if (player.score < node->player.score)
            node->left = insertNode(node->left, player);
        else if (player.score > node->player.score)
            node->right = insertNode(node->right, player);
        else
            return node; // Duplicate scores are not allowed

        // Update height of current node
        node->height = 1 + max(height(node->left), height(node->right));

        // Get the balance factor
        int balance = balanceFactor(node);

        // Perform rotations if needed to balance the tree
        if (balance > 1 && player.score < node->left->player.score)
            return rightRotate(node);

        if (balance < -1 && player.score > node->right->player.score)
            return leftRotate(node);

        if (balance > 1 && player.score > node->left->player.score) {
            node->left = leftRotate(node->left);
            return rightRotate(node);
        }

        if (balance < -1 && player.score < node->right->player.score) {
            node->right = rightRotate(node->right);
            return leftRotate(node);
        }

        return node;
    }

    AVLNode* minValueNode(AVLNode* node) {
        AVLNode* current = node;
        while (current->left != nullptr)
            current = current->left;
        return current;
    }

    AVLNode* deleteNode(AVLNode* root, int score) {
        if (root == nullptr)
            return root;

        if (score < root->player.score)
            root->left = deleteNode(root->left, score);
        else if (score > root->player.score)
            root->right = deleteNode(root->right, score);
        else {
            if ((root->left == nullptr) || (root->right == nullptr)) {
                AVLNode* temp = root->left ? root->left : root->right;
                if (temp == nullptr) {
                    temp = root;
                    root = nullptr;
                } else {
                    *root = *temp;
                }
                delete temp;
            } else {
                AVLNode* temp = minValueNode(root->right);
                root->player = temp->player;
                root->right = deleteNode(root->right, temp->player.score);
            }
        }

        if (root == nullptr)
            return root;

        root->height = 1 + max(height(root->left), height(root->right));

        int balance = balanceFactor(root);

        if (balance > 1 && balanceFactor(root->left) >= 0)
            return rightRotate(root);

        if (balance > 1 && balanceFactor(root->left) < 0) {
            root->left = leftRotate(root->left);
            return rightRotate(root);
        }

        if (balance < -1 && balanceFactor(root->right) <= 0)
            return leftRotate(root);

        if (balance < -1 && balanceFactor(root->right) > 0) {
            root->right = rightRotate(root->right);
            return leftRotate(root);
        }

        return root;
    }

    void inOrderTraversal(AVLNode* node) {
        if (node != nullptr) {
            inOrderTraversal(node->left);
            cout << "Username: " << node->player.username
                 << ", Score: " << node->player.score
                 << ", Rank: " << node->player.rank << endl;
            inOrderTraversal(node->right);
        }
    }

public:
    AVLTree() : root(nullptr) {}

    void insertPlayer(PlayerRecord player) {
        root = insertNode(root, player);
    }

    void deletePlayer(int score) {
        root = deleteNode(root, score);
    }

    void printLeaderboard() {
        cout << "Leaderboard:\n";
        inOrderTraversal(root);
    }
};

int main() {
    AVLTree leaderboard;

    // Adding players to the leaderboard
    leaderboard.insertPlayer(PlayerRecord("Player1", 1500));
    leaderboard.insertPlayer(PlayerRecord("Player2", 1200));
    leaderboard.insertPlayer(PlayerRecord("Player3", 1800));
    leaderboard.insertPlayer(PlayerRecord("Player4", 1600));
    leaderboard.insertPlayer(PlayerRecord("Player5", 1400));

    // Printing the initial leaderboard
    cout << "Initial Leaderboard:\n";
    leaderboard.printLeaderboard();

    // Modifying scores
    leaderboard.insertPlayer(PlayerRecord("Player6", 1550));
    leaderboard.insertPlayer(PlayerRecord("Player7", 1300));
    leaderboard.insertPlayer(PlayerRecord("Player8", 1700));

    // Printing the updated leaderboard
    cout << "\nUpdated Leaderboard:\n";
    leaderboard.printLeaderboard();

    // Removing inactive players
    leaderboard.deletePlayer(1300);
    leaderboard.deletePlayer(1800);

    // Printing the final leaderboard
    cout << "\nFinal Leaderboard:\n";
    leaderboard.printLeaderboard();

    return 0;
}
//end of avl 





















//graphs

#include <iostream>
#include <vector>
#include <queue>

using namespace std;

class Graph {
private:
    int V; // Number of vertices
    vector<vector<int>> adjList; // Adjacency list

public:
    // Constructor to initialize the graph with a given number of vertices
    Graph(int vertices) : V(vertices), adjList(vertices) {}

    // Function to add an edge between two vertices
    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u); // Assuming an undirected graph
    }

    // Breadth-First Search to find the shortest path between two users
    vector<int> bfsShortestPath(int start, int end) {
        vector<int> distance(V, -1);
        queue<int> q;

        q.push(start);
        distance[start] = 0;

        while (!q.empty()) {
            int current = q.front();
            q.pop();

            for (int neighbor : adjList[current]) {
                if (distance[neighbor] == -1) {
                    q.push(neighbor);
                    distance[neighbor] = distance[current] + 1;
                }
            }
        }

        return distance;
    }

    // Depth-First Search to identify connected components
    void dfsConnectedComponents(int node, vector<bool>& visited, vector<int>& component) {
        visited[node] = true;
        component.push_back(node);

        for (int neighbor : adjList[node]) {
            if (!visited[neighbor]) {
                dfsConnectedComponents(neighbor, visited, component);
            }
        }
    }

    // Function to find connected components
    vector<vector<int>> findConnectedComponents() {
        vector<vector<int>> components;
        vector<bool> visited(V, false);

        for (int i = 0; i < V; ++i) {
            if (!visited[i]) {
                vector<int> component;
                dfsConnectedComponents(i, visited, component);
                components.push_back(component);
            }
        }

        return components;
    }

    // Function to suggest friends based on mutual connections using BFS
    vector<int> suggestFriends(int user) {
        vector<int> suggestedFriends;
        vector<bool> visited(V, false);

        queue<int> q;
        q.push(user);
        visited[user] = true;

        while (!q.empty()) {
            int current = q.front();
            q.pop();

            for (int neighbor : adjList[current]) {
                if (!visited[neighbor]) {
                    q.push(neighbor);
                    visited[neighbor] = true;

                    // Include mutual friends of the starting user
                    suggestedFriends.push_back(neighbor);

                    for (int mutualFriend : adjList[neighbor]) {
                        if (!visited[mutualFriend] && mutualFriend != user) {
                            suggestedFriends.push_back(mutualFriend);
                        }
                    }
                }
            }
        }

        return suggestedFriends;
    }

    // Function to find influencers (nodes with significant connections)
    vector<int> findInfluencers() {
        vector<int> influencers;
        const int THRESHOLD = 2; // Adjust threshold as needed

        for (int i = 0; i < V; ++i) {
            if (adjList[i].size() >= THRESHOLD) {
                influencers.push_back(i);
            }
        }

        return influencers;
    }
};

int main() {
    int numUsers;

    // Get the number of users from the user
    cout << "Enter the number of users in the social network: ";
    cin >> numUsers;

    // Create a social network graph with the specified number of users
    Graph socialNetwork(numUsers);

    // Menu for user interaction
    int choice;
    do {
        cout << "\nSocial Network Menu:\n";
        cout << "1. Add an edge between users\n";
        cout << "2. Find the shortest path between two users\n";
        cout << "3. Find connected components in the network\n";
        cout << "4. Suggest friends for a user\n";
        cout << "5. Find influencers in the network\n";
        cout << "0. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
            case 1: {
                int user1, user2;
                cout << "Enter user IDs to add an edge (space-separated): ";
                cin >> user1 >> user2;
                socialNetwork.addEdge(user1, user2);
                cout << "Edge added between users " << user1 << " and " << user2 << "\n";
                break;
            }
            case 2: {
                int start, end;
                cout << "Enter user IDs to find the shortest path (space-separated): ";
                cin >> start >> end;
                vector<int> shortestPath = socialNetwork.bfsShortestPath(start, end);
                cout << "Shortest path from user " << start << " to user " << end << ": "
                     << shortestPath[end] << " hops\n";
                break;
            }
            case 3: {
                vector<vector<int>> components = socialNetwork.findConnectedComponents();
                cout << "Connected components in the network:\n";
                for (const auto& component : components) {
                    for (int node : component) {
                        cout << node << " ";
                    }
                    cout << "\n";
                }
                break;
            }
            case 4: {
                int user;
                cout << "Enter user ID to suggest friends: ";
                cin >> user;
                vector<int> suggestedFriends = socialNetwork.suggestFriends(user);
                cout << "Suggested friends for user " << user << ": ";
                for (int friendNode : suggestedFriends) {
                    cout << friendNode << " ";
                }
                cout << "\n";
                break;
            }
            case 5: {
                vector<int> influencers = socialNetwork.findInfluencers();
                cout << "Influencers in the network: ";
                for (int influencer : influencers) {
                    cout << influencer << " ";
                }
                cout << "\n";
                break;
            }
            case 0:
                cout << "Exiting the social network program.\n";
                break;
            default:
                cout << "Invalid choice. Please enter a valid option.\n";
        }
    } while (choice != 0);

    return 0;
}















































































//part2

//graph

#include <iostream>
#include <vector>
#include <queue>
#include <stack>

using namespace std;

class Graph {
private:
    vector<vector<int>> adjacencyList;

public:
    Graph(int numVertices) : adjacencyList(numVertices) {}

    void addEdge(int src, int dest) {
        // Add edge from src to dest
        adjacencyList[src].push_back(dest);

        // Since the graph is undirected, add edge from dest to src as well
        adjacencyList[dest].push_back(src);
    }

    void printGraph() {
        for (int i = 0; i < adjacencyList.size(); ++i) {
            cout << "Vertex " << i << " is connected to: ";
            for (int neighbor : adjacencyList[i]) {
                cout << neighbor << " ";
            }
            cout << endl;
        }
    }

    void bfs(int startVertex) {
        vector<bool> visited(adjacencyList.size(), false);
        queue<int> q;

        visited[startVertex] = true;
        q.push(startVertex);

        cout << "BFS starting from vertex " << startVertex << ": ";
        while (!q.empty()) {
            int currentVertex = q.front();
            q.pop();
            cout << currentVertex << " ";

            for (int neighbor : adjacencyList[currentVertex]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.push(neighbor);
                }
            }
        }
        cout << endl;
    }

    void dfs(int startVertex) {
        vector<bool> visited(adjacencyList.size(), false);
        stack<int> s;

        s.push(startVertex);

        cout << "DFS starting from vertex " << startVertex << ": ";
        while (!s.empty()) {
            int currentVertex = s.top();
            s.pop();

            if (!visited[currentVertex]) {
                cout << currentVertex << " ";
                visited[currentVertex] = true;
            }

            for (int neighbor : adjacencyList[currentVertex]) {
                if (!visited[neighbor]) {
                    s.push(neighbor);
                }
            }
        }
        cout << endl;
    }
};

int main() {
    // Specify the number of vertices in the graph
    int numVertices = 4;

    Graph graph(numVertices);

    // Adding edges to the graph
    graph.addEdge(0, 1);
    graph.addEdge(0, 2);
    graph.addEdge(1, 2);
    graph.addEdge(2, 0);
    graph.addEdge(2, 3);
    graph.addEdge(3, 3);

    // Printing the graph
    cout << "Graph representation using adjacency lists:" << endl;
    graph.printGraph();

    // Perform BFS starting from vertex 0
    graph.bfs(0);

    // Perform DFS starting from vertex 0
    graph.dfs(0);

    return 0;
}
















































//hashmaps

#include <iostream>
#include <list>
#include <utility>

using namespace std;

// User ADT
struct User {
    string firstName;
    string lastName;
    int birthdate;  // Represented as an integer in the format YYYYMMDD
};

// Hash table using chaining to handle collisions
class UserHashTable {
private:
    static const size_t tableSize = 100;  // Adjust as needed
    list<pair<int, User>> table[tableSize];

public:
    // Manual hash function to generate a unique hash code
    size_t generateHash(const User& user) {
        // Directly use birthdate as the key
        return user.birthdate % tableSize;
    }

    // Add a new user to the hash table
    void addUser(const User& user) {
        size_t index = generateHash(user);
        table[index].push_back({user.birthdate, user});
        cout << "User added successfully.\n";
    }

    // Search for a user in the hash table
    void searchUser(const User& user) {
        size_t index = generateHash(user);
        for (const auto& entry : table[index]) {
            if (entry.second.firstName == user.firstName &&
                entry.second.lastName == user.lastName &&
                entry.second.birthdate == user.birthdate) {
                cout << "User found: " << entry.second.firstName << " " << entry.second.lastName << " "
                     << entry.second.birthdate << "\n";
                return;
            }
        }
        cout << "User not found.\n";
    }

    // Delete a user from the hash table
    void deleteUser(const User& user) {
        size_t index = generateHash(user);
        table[index].remove_if([&](const auto& entry) {
            return entry.second.firstName == user.firstName &&
                   entry.second.lastName == user.lastName &&
                   entry.second.birthdate == user.birthdate;
        });
        cout << "User deleted successfully.\n";
    }
};

int main() {
    UserHashTable userTable;

    while (true) {
        cout << "\nUser Identification System Menu:\n";
        cout << "1. Add New User\n";
        cout << "2. Search for User\n";
        cout << "3. Delete User\n";
        cout << "4. Exit\n";
        cout << "Enter your choice: ";

        int choice;
        cin >> choice;

        switch (choice) {
            case 1: {
                User newUser;
                cout << "Enter first name: ";
                cin >> newUser.firstName;
                cout << "Enter last name: ";
                cin >> newUser.lastName;
                cout << "Enter birthdate (YYYYMMDD): ";
                cin >> newUser.birthdate;
                userTable.addUser(newUser);
                break;
            }
            case 2: {
                User searchUser;
                cout << "Enter first name: ";
                cin >> searchUser.firstName;
                cout << "Enter last name: ";
                cin >> searchUser.lastName;
                cout << "Enter birthdate (YYYYMMDD): ";
                cin >> searchUser.birthdate;
                userTable.searchUser(searchUser);
                break;
            }
            case 3: {
                User deleteUser;
                cout << "Enter first name: ";
                cin >> deleteUser.firstName;
                cout << "Enter last name: ";
                cin >> deleteUser.lastName;
                cout << "Enter birthdate (YYYYMMDD): ";
                cin >> deleteUser.birthdate;
                userTable.deleteUser(deleteUser);
                break;
            }
            case 4:
                cout << "Exiting program.\n";
                return 0;
            default:
                cout << "Invalid choice. Please try again.\n";
        }
    }

    return 0;
}


















//bst

#include <iostream>
using namespace std;

class node {
public:
    int val;
    node* left;
    node* right;

    node(int v) {
        val = v;
        left = nullptr;
        right = nullptr;
    }
};

class bst {
private:
    node* root;

    node* insertNode(node* root, int val) {
        if (root == nullptr)
            return new node(val);

        if (val > root->val)
            root->right = insertNode(root->right, val);
        else if (val < root->val)
            root->left = insertNode(root->left, val);

        return root;
    }

    node* searchNode(node* root, int val) {
        if (root == nullptr || root->val == val)
            return root;

        if (val < root->val)
            return searchNode(root->left, val);
        else
            return searchNode(root->right, val);
    }

    node* findMin(node* root) {
        while (root->left != nullptr) {
            root = root->left;
        }
        return root;
    }

    node* deleteNode(node* root, int val) {
        node* targetNode = searchNode(root, val);

        if (targetNode == nullptr)
            return root; // Node not found

        // Proceed with deletion based on the found target node
        if (targetNode->left == nullptr) {
            node* temp = targetNode->right;
            delete targetNode;
            return temp;
        } else if (targetNode->right == nullptr) {
            node* temp = targetNode->left;
            delete targetNode;
            return temp;
        }

        // Node with two children
        node* temp = findMin(targetNode->right);
        targetNode->val = temp->val;
        targetNode->right = deleteNode(targetNode->right, temp->val);

        return targetNode;
    }

    void inorderTraversal(node* root) {
        if (root != nullptr) {
            inorderTraversal(root->left);
            cout << root->val << ",";
            inorderTraversal(root->right);
        }
    }

public:
    bst() {
        root = nullptr;
    }

    void insert(int val) {
        root = insertNode(root, val);
    }

    void remove(int val) {
        root = deleteNode(root, val);
    }

    void inorder() {
        inorderTraversal(root);
        cout << endl;
    }
};

int main() {
    bst tree;
    tree.insert(22);
    tree.insert(6);
    tree.insert(5);
    tree.insert(2);
    tree.insert(65);
    tree.insert(32);
    tree.insert(11);
    tree.insert(33);
    tree.insert(77);
    tree.insert(4);
    tree.insert(1);

    cout << "Original tree: ";
    tree.inorder();

    tree.remove(6);

    cout << "Tree after removing 6: ";
    tree.inorder();

    return 0;
}






































//avl
#include <iostream>
using namespace std;

class AVLNode {
public:
    int key;
    int height;
    AVLNode* left;
    AVLNode* right;

    AVLNode(int k) : key(k), height(1), left(nullptr), right(nullptr) {}
};

class AVLTree {
private:
    AVLNode* root;

    int max(int a, int b) {
        return (a > b) ? a : b;
    }

    int height(AVLNode* node) {
        return (node == nullptr) ? 0 : node->height;
    }

    int getBalance(AVLNode* node) {
        return (node == nullptr) ? 0 : height(node->left) - height(node->right);
    }

    AVLNode* rotateRight(AVLNode* y) {
        AVLNode* x = y->left;
        AVLNode* T2 = x->right;

        x->right = y;
        y->left = T2;

        y->height = 1 + max(height(y->left), height(y->right));
        x->height = 1 + max(height(x->left), height(x->right));

        return x;
    }

    AVLNode* rotateLeft(AVLNode* x) {
        AVLNode* y = x->right;
        AVLNode* T2 = y->left;

        y->left = x;
        x->right = T2;

        x->height = 1 + max(height(x->left), height(x->right));
        y->height = 1 + max(height(y->left), height(y->right));

        return y;
    }

    AVLNode* minValueNode(AVLNode* node) {
        AVLNode* current = node;
        while (current->left != nullptr) {
            current = current->left;
        }
        return current;
    }

    AVLNode* deleteNode(AVLNode* root, int key) {
        if (root == nullptr)
            return root; // Key not found

        if (key < root->key)
            root->left = deleteNode(root->left, key);
        else if (key > root->key)
            root->right = deleteNode(root->right, key);
        else {
            // Node with the key is found

            // Case 1: Node with only one child or no child
            if (root->left == nullptr) {
                AVLNode* temp = root->right;
                delete root;
                return temp;
            } else if (root->right == nullptr) {
                AVLNode* temp = root->left;
                delete root;
                return temp;
            }

            // Case 2: Node with two children
            AVLNode* temp = minValueNode(root->right);
            root->key = temp->key;
            root->right = deleteNode(root->right, temp->key);
        }

        // Update height of the current node
        root->height = 1 + max(height(root->left), height(root->right));

        // Get the balance factor to check if rotation is needed
        int balance = getBalance(root);

        // Left Left Case
        if (balance > 1 && getBalance(root->left) >= 0)
            return rotateRight(root);

        // Left Right Case
        if (balance > 1 && getBalance(root->left) < 0) {
            root->left = rotateLeft(root->left);
            return rotateRight(root);
        }

        // Right Right Case
        if (balance < -1 && getBalance(root->right) <= 0)
            return rotateLeft(root);

        // Right Left Case
        if (balance < -1 && getBalance(root->right) > 0) {
            root->right = rotateRight(root->right);
            return rotateLeft(root);
        }

        return root;
    }

    void inorderTraversal(AVLNode* node) {
        if (node != nullptr) {
            inorderTraversal(node->left);
            cout << node->key << " ";
            inorderTraversal(node->right);
        }
    }

public:
    AVLTree() : root(nullptr) {}

    void insert(int key) {
        root = insertNode(root, key);
    }

    void remove(int key) {
        root = deleteNode(root, key);
    }

    void inorder() {
        inorderTraversal(root);
        cout << endl;
    }
};

int main() {
    AVLTree avlTree;

    avlTree.insert(10);
    avlTree.insert(20);
    avlTree.insert(30);
    avlTree.insert(40);
    avlTree.insert(50);
    avlTree.insert(25);

    cout << "Inorder traversal of AVL tree: ";
    avlTree.inorder();

    avlTree.remove(30);

    cout << "AVL tree after removing 30: ";
    avlTree.inorder();

    return 0;
}











//quicksort
#include <iostream>

using namespace std;

void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

int partition(int arr[], int low, int high) {
    int pivot = arr[high];  // Choose the last element as the pivot
    int i = low - 1;  // Index of smaller element

    for (int j = low; j < high; ++j) {
        if (arr[j] <= pivot) {
            // Swap arr[i] and arr[j]
            i++;
            swap(arr[i], arr[j]);
        }
    }

    // Swap arr[i + 1] and arr[high] (put the pivot in the correct position)
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

void quicksort(int arr[], int low, int high) {
    if (low < high) {
        // Partition the array and get the index of the pivot element
        int pivotIndex = partition(arr, low, high);

        // Recursively sort the subarrays
        quicksort(arr, low, pivotIndex - 1);
        quicksort(arr, pivotIndex + 1, high);
    }
}

int main() {
    const int arraySize = 20;
    int arr[arraySize] = {12, 5, 3, 17, 8, 10, 1, 19, 6, 15, 14, 7, 13, 4, 11, 18, 2, 20, 9, 16};

    cout << "Original array: ";
    for (int i = 0; i < arraySize; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;

    quicksort(arr, 0, arraySize - 1);

    cout << "Sorted array: ";
    for (int i = 0; i < arraySize; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}




//quicksort

#include <iostream>

using namespace std;

void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    // Create temporary arrays
    int leftArray[n1];
    int rightArray[n2];

    // Copy data to temporary arrays leftArray[] and rightArray[]
    for (int i = 0; i < n1; ++i)
        leftArray[i] = arr[left + i];
    for (int j = 0; j < n2; ++j)
        rightArray[j] = arr[mid + 1 + j];

    // Merge the temporary arrays back into arr[left..right]
    int i = 0; // Initial index of first subarray
    int j = 0; // Initial index of second subarray
    int k = left; // Initial index of merged subarray

    while (i < n1 && j < n2) {
        if (leftArray[i] <= rightArray[j]) {
            arr[k] = leftArray[i];
            ++i;
        } else {
            arr[k] = rightArray[j];
            ++j;
        }
        ++k;
    }

    // Copy the remaining elements of leftArray[], if there are any
    while (i < n1) {
        arr[k] = leftArray[i];
        ++i;
        ++k;
    }

    // Copy the remaining elements of rightArray[], if there are any
    while (j < n2) {
        arr[k] = rightArray[j];
        ++j;
        ++k;
    }
}

void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        // Same as (left+right)/2, but avoids overflow for large left and right
        int mid = left + (right - left) / 2;

        // Sort first and second halves
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);

        // Merge the sorted halves
        merge(arr, left, mid, right);
    }
}

int main() {
    const int arraySize = 20;
    int arr[arraySize] = {12, 5, 3, 17, 8, 10, 1, 19, 6, 15, 14, 7, 13, 4, 11, 18, 2, 20, 9, 16};

    cout << "Original array: ";
    for (int i = 0; i < arraySize; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;

    mergeSort(arr, 0, arraySize - 1);

    cout << "Sorted array: ";
    for (int i = 0; i < arraySize; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}

